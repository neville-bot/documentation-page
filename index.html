<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
    <title>Document</title>
  </head>
  <body>
    <div id="doc-container">
      <nav id="navbar">
        <ul>
          <li><header>Node.js Documentation</header></li>
          <li><a href="#Introduction">Introduction</a></li>
          <li><a href="#Node_And_V8">Node And V8</a></li>
          <li>
            <a href="#What_you_should_already_know"
              >What you should already know</a
            >
          </li>
          <li><a href="#Hello_World">Hello World</a></li>
          <li>
            <a href="#Blocking_Vs_Non-Blocking">Blocking Vs Non-Blocking</a>
          </li>
          <li><a href="#Node_API">Node API</a></li>
          <li><a href="#Event_Loop">Event Loop</a></li>
          <li><a href="#Timers">Timers</a></li>
          <li><a href="#HTTP_Transaction">HTTP Transaction</a></li>
        </ul>
      </nav>
      <main id="main-doc">
        <section class="main-section" id="Introduction">
          <header>Introduction</header>
          <p>
            Node.js is a Javscript runtime built on the V8 Javscript engine. It
            is used to execute Javascript code outside of a web browser
          </p>
          <p>Node.js is single threaded, non-blocking, and asynchronous.</p>
          <ul>
            <li>
              A node app runs in a single process, without creating a new thread
              for every request.
            </li>
            <li>
              Libraries in Node.js are written using non-blocking paradigms,
              making blocking behavior the exception rather than the norm.
            </li>
          </ul>
        </section>
        <section class="main-section" id="Node_and_V8">
          <header>Node and V8</header>
          <p>
            V8 is Google's open source high-performace Javascript engine(written
            in C++)
          </p>
          <p>
            V8 comiles and executes Javascript source code, handles memeory
            allocation for objects, and garbage collects objects it no longer
            needs.
          </p>
          <ul>
            <li>
              JavaScript is commonly used for client-side scripting in the
              browser, being used to manipulate Document Object Model(DOM)
              objects for example.
            </li>
            <li>
              The DOM is not typically provided by the Javascript engine, but by
              the browser. Same for V8, Google Chrome provides the DOM. V8 does
              however provide all the data types, operators, objects, and
              functions specified in the ECMA standard.
            </li>
          </ul>
        </section>
        <section class="main-section" id="What_you_should_already_know">
          <header>What you should already know</header>
          <p>
            As a beginner, it's hard to get to a point where you are confident
            enough in your programming abilities. While learning to code, you
            might also be confused at where does JavaScript end, and where
            Node.js begins, and vice versa. I would recommend you to have a good
            grasp of the main JavaScript concepts before diving into Node.js:
          </p>

          <ul>
            <li>Lexical Structure</li>
            <li>Expressions</li>
            <li>Types</li>
            <li>Scopes</li>
            <li>Classes</li>
            <li>Variables</li>
            <li>Functions</li>
            <li>this</li>
            <li>Arrow Functions</li>
            <li>Loops</li>
            <li>Arrays</li>
            <li>Template Literals</li>
            <li>Semicolons</li>
            <li>Strict Mode</li>
            <li>ECMAScript 6, 2016, 2017</li>
          </ul>
        </section>

        <section class="main-section" id="Hello_World">
          <header>Hello World</header>
          <p>The most common example for Node.js is a web server:</p>
          <p>
            <code
              >const server = http.createServer((req, res) => {
              <br />
              res.statusCode = 200 res.setHeader('Content-Type', 'text/plain')
              res.end('Hello World\n') })
            </code>
          </p>
        </section>
        <section class="main-section" id="Blocking_Vs_Non-Blocking">
          <header>Blocking Vs Non-Blocking</header>
          <p>
            Blocking is when the execution of additional JavaScript in the
            Node.js process must wait until a non-JavaScript operation
            completes. This happens because the event loop is unable to continue
            running JavaScript while a blocking operation is occurring.
          </p>
          <p>
            All of the I/O methods in the Node.js standard library provide
            asynchronous versions, which are non-blocking, and accept callback
            functions. Some methods also have blocking counterparts, which have
            names that end with Sync.
          </p>
          <p>
            Using the File System module as an example, this is a synchronous
            file read:
          </p>
          <code
            >const fs = require('fs');
            <br />
            const data = fs.readFileSync('/file.md'); //blocks here until file
            is read</code
          >
          <p>And here is an equivalent asynchronous example:</p>
          <code
            >const fs = require('fs');
            <br />
            fs.readFile('/file.md', (err, data) => { if (err) throw err;
            });</code
          >
        </section>
        <section class="main-section" id="Node_API">
          <header>Node API</header>
          <p>
            Node-API (formerly N-API) is an API for building native Addons. It
            is independent from the underlying JavaScript runtime (for example,
            V8) and is maintained as part of Node.js itself.
          </p>
          <p>
            APIs exposed by Node-API are generally used to create and manipulate
            JavaScript values. Concepts and operations generally map to ideas
            specified in the ECMA-262 Language Specification. The APIs have the
            following properties:
          </p>
          <ul>
            <li>
              All Node-API calls return a status code of type napi_status. This
              status indicates whether the API call succeeded or failed.
            </li>
            <li>The API's return value is passed via an out parameter.</li>
            <li>
              All JavaScript values are abstracted behind an opaque type named
              napi_value.
            </li>
            <li>
              In case of an error status code, additional information can be
              obtained using napi_get_last_error_info.
            </li>
          </ul>
          <p>
            Perhaps the most popular use for Node-API is making the capabilities
            of an existing C/C++ library available to JavaScript programmers.
            This permits you to leverage the investment youâ€™ve already made in
            your existing code, making it available to a whole new population of
            JavaScript programmers and projects.
          </p>
        </section>
        <section class="main-section" id="Event_Loop">
          <header>Event Loop</header>
          <p>
            The Event Loop is the main thread of Node.js. It is responsible for
            scheduling and executing tasks.
          </p>
          <ul>
            <li>
              Node.js can be asynchronous and have non-blocking I/O, and so it
              explains basically the "killer app" of Node.js, the thing that
              made it this successful.
            </li>
            <li>
              The Node.js JavaScript code runs on a single thread. There is just
              one thing happening at a time.
            </li>
            <li>
              This simplifies how you program as you don't have to worry about
              concurrency issues.
            </li>
            <li>
              Avoid blocking the thread: synchronous network calls or infinite
              loops.
            </li>
            <li>
              In general, in most browsers there is an event loop for every
              browser tab, to make every process isolated and avoid a web page
              with infinite loops or heavy processing to block your entire
              browser.
            </li>
          </ul>
        </section>

        <section class="main-section" id="Call_Stack">
          <header>The Call Stack</header>
          <p>The call stack is a LIFO (Last In, First Out) stack.</p>
          <ul>
            <li>
              The event loop continuously checks the call stack to see if
              there's any function that needs to run.
            </li>
            <li>
              While doing so, it adds any function call it finds to the call
              stack and executes each one in order.
            </li>
          </ul>
        </section>
        <section class="main-section" id="Timers">
          <header>Timers</header>
        </section>
        <section class="main-section" id="HTTP_Transaction">
          <header>HTTP Transaction</header>
        </section>
      </main>
    </div>

    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
  </body>
</html>
